/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "clientdb.h"
#include "oauth.h"
#include "utils/utils.h"
#include <bits/stdc++.h>
#include <fstream>
#include <iostream>
#include <stdio.h>
#include <string>
#include <vector>

using namespace std;

#define HOST "127.0.0.1"
#define MAX_LINE_SIZE 50
#define MAX_USER_ID_LENGTH 50
#define MAX_RESOURCE_SIZE 50
#define MAX_ACCESS_TOKEN_SIZE 50

/**
 * Process each line from the input to create an operation structure
 *
 * @param line from input file
 * @return operation structure containing all info about future actions
 */
operation *process_line(string line) {
	stringstream ss(line);
	int idx = 0;
	operation *op = (operation *)malloc(sizeof(operation));
	op->user_id = (char *)malloc(MAX_USER_ID_LENGTH * sizeof(char));
	op->automatic_refresh = -1;

	while (ss.good()) {
		string substr;
		getline(ss, substr, ',');
		switch (idx) {
		case 0:
			strcpy(op->user_id, substr.c_str());
			break;
		case 1:
			op->operation_type = strdup(substr.c_str());
			break;
		case 2:
			if (string_to_operation_type(op->operation_type) == REQUEST) {
				op->automatic_refresh = stoi(substr);
				op->resource = NULL;
			} else {
				op->resource = (char *)malloc(MAX_RESOURCE_SIZE * sizeof(char));
				strcpy(op->resource, substr.c_str());
			}
			break;
		default:
			break;
		}
		idx++;
	}
	return op;
}

void processOperation(operation *op) {
	CLIENT *clnt;
#ifndef DEBUG
	clnt = clnt_create(HOST, AUTHORIZATION, OAUTH, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(HOST);
		exit(1);
	}
#endif /* DEBUG */

	if (string_to_operation_type(op->operation_type) == REQUEST) {
		// REQUEST to get the authentication token from the server
		char **result_auth = auth_1(&(op->user_id), clnt);
		if (result_auth == (char **)NULL) {
			clnt_perror(clnt, "call failed");
		}

		// Return if user has not been found
		if (strcmp(res_code_to_str[USER_NOT_FOUND], *result_auth) == 0) {
			cout << res_code_to_str[USER_NOT_FOUND] << endl;
			return;
		}

		// REQUEST to attach permissions to the token
		char **result_approval = approve_req_token_1(result_auth, clnt);
		if (result_approval == (char **)NULL) {
			clnt_perror(clnt, "call failed");
		}

		// Create Access Request structure
		access_token_req *access_request =
			(access_token_req *)malloc(sizeof(access_token_req));
		access_request->auth_token = *result_approval;
		access_request->user_id = op->user_id;
		access_request->auto_refresh = op->automatic_refresh;

		// REQUEST to get the access token
		access_token_struct *access_response = access_1(access_request, clnt);
		if (access_response == (access_token_struct *)NULL) {
			clnt_perror(clnt, "call failed");
		}

		// Return if request has been denied
		if (strcmp(access_response->access_token,
				   res_code_to_str[REQUEST_DENIED]) == 0) {
			cout << res_code_to_str[REQUEST_DENIED] << endl;
			return;
		}
		// Add {user:access_token} pair into the client database
		clientsTokens[op->user_id] = *access_response;
		cout << *result_auth << " -> " << access_response->access_token;
		if (strcmp(access_response->refresh_token, "") != 0) {
			cout << "," << access_response->refresh_token;
		}
		cout << endl;

	} else {
		action_req *action_request = (action_req *)malloc(sizeof(action_req));

		// Check if the user is valid and has a token
		if (clientsTokens.count(op->user_id) != 0) {

			action_request->access_token =
				clientsTokens.at(op->user_id).access_token;

			// Refresh if the token is expired and auto-refresh option is active
			if (strlen(clientsTokens.at(op->user_id).refresh_token) > 1 &&
				clientsTokens.at(op->user_id).valability == 0) {
				access_token_struct *refresh_response =
					refresh_access_1(&(clientsTokens.at(op->user_id)), clnt);
				// Update token in the clients db
				clientsTokens[op->user_id].access_token =
					refresh_response->access_token;
				clientsTokens[op->user_id].refresh_token =
					refresh_response->refresh_token;
				clientsTokens[op->user_id].valability =
					refresh_response->valability;
			}
			action_request->access_token =
				clientsTokens[op->user_id].access_token;
		} else {
			action_request->access_token = strdup("");
		}
		action_request->operation = op->operation_type;
		action_request->resource = op->resource;

		// REQUEST to validate an action
		char **action_response = validate_action_1(action_request, clnt);
		if (action_response == (char **)NULL) {
			clnt_perror(clnt, "call failed");
		}

		cout << *action_response << endl;

		//  Decrease remaining requests
		if (clientsTokens.count(op->user_id) > 0) {
			clientsTokens.at(op->user_id).valability--;
		}
	}
	clnt_destroy(clnt);
}

void read_operations(ifstream &input_file) {
	string line;

	while (input_file >> line) {
		operation *op = process_line(line);
		processOperation(op);
	}
}

int main(int argc, char *argv[]) {
	char *operations_file;

	if (argc < 3) {
		printf("usage: %s <client_addr> <operation_file>\n", argv[0]);
		exit(1);
	}

	operations_file = argv[2];
	ifstream input_file(operations_file);
	read_operations(input_file);

	exit(0);
}
